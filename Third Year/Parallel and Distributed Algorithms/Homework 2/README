Student: CAULEA Gheorghita
Grupa: 	 334CB

	In inceputul implementarii acestei teme mi-am creat cateva functii ajutatoare. Acestea sunt urmatoarele:
-functia 'getNeigh': functie ce primeste ca parametru linia corespunzatoare unui proces din fisierul de topologie si creeaza vectorul ce copii corespunzator.
-functia 'getFirst': functie ce primeste o linie si intoarce primul intreg de pe acea linie.
-functie 'getFiltre': functie ce primiste ca parametru o linie de tipul celor din fisierul de imagini si returneaza filtrul ce se vrea a fi aplicat pentru imaginea respectiva.
-functia 'getImageName': functie ce primeste o linie din fisierul 'imagini.in' si intoarce numele imaginii de procesat.
-functia 'getOutputImageName': functie ce primeste o linie din fisierul 'imagini.in' si intoarce numele imaginii procesate.
-functia 'my_aprox': functie ce primeste valoarea unui pizel calculata dupa aplicatrea unui filttru si aproximeaza acesta valoare intre limitele in care se poate incadra valoarea unui pixil(0-255).
-functia 'apply_filtre': acesta functie primeste ca parametru blocul din imagine ce urmeaza a fi procesat, inaltimea si latimea si filtrul pe care trebuie sa il aplice. Transforma blocul intr-o matrice pentru a a aplica mai usor filtru si apoi calculeaza noile valori ale pixelilor in functie de filtrul ce trebuie aplicat. La final tranforma totul intr-un vector pe care il intoarce.
	Dupa crearea acestor functie urmeaza functia main in care deschid fisierul de imagini si obtin parametrul NF(numarul de imagini de procesat). Pentru fiecare imagine voi executa urmatoarele: Pentru procesul 0(radacina) voi construi vectorul de copii aplicand functia special creata pe linia corespunzatoare procesului si anume linia 0. Dupa construirea vectorului de copii determin filtrul ce urmeaza a fi aplicat pe imaginea respectiva. Pasul cu filtrul este necesar deoarece trimit informatii pe canale diferite in functie de filstrul care se doreste a fi aplicat pe imaginea data. Deschid imaginea de procesat si scopul meu in acest moment este de a sari peste header si a ajunge la informatii esentiale(width, height si pixelii). Secventa de instructiunii ce urmareste sarirea peste headerul imaginii are in vedere si memeorarea liniilor pe care aceste le contine, lucru care va ajuta la final la construirea imaginii de output(va trebui sa pun headerul si in imaginea de output, si acesta va trebui sa fie exact in forma in care se gaseste acum). Un pas foarte important de asemenea in momentul in care ajung sa citesc pixelii este sa retin separatorul din acestia. Dupa ce am determinat elementele esentiale ale imaginii, pe canalul corespunzator filstrului care se vrea aplicat(1-sobel, 2-mean) transmit catre procesele copil parametrul width. Pe acelasi canal transmit si parametrul height(acesta este calculat in functie de numarul de copii). Voi imparti blocul imagini initial in blocuri de inaltime corespunzatoare parametrului height transmis. Ultimul copil va lua ce ramane din blocul imagine initial. Dupa transmiterea blocurilor de imagine catre copii astept primirea blocurilor de imagine(dar acum cu valorile modificate pentru fiecare pixel). Voi scrie noul bloc imagine in imaginea ce va reprezenta outputul alaturi de vechiul header si tinand cont de separatorul ce separa fiecare pixel in imaginea initiala. Daca s-a ajuns la finalul procesarii, adica daca nu mai sunt imagini de procesat astept de la fiecare copil un vector ce reprezinta elementul de statistica si are dimensiunea primita printr-ul alt mesaj. Vectorul acesta este de forma: <rank_proc> <linii_procesate>. Voi ordona acest vector dupa care il voi scrie in fisierul de statistica.
	Pentru fiecare proces care nu este radacina voi citi linia corespunzatoare din fisierul de topologie si voi determina vectorul de copii. Pentru procesele intermediare(procese care nu sunt nici radacina nici frunza) se vor executa urmatoarele instructiuni. Astept primirea latimii blocului de imagine. Prin acest prim mesaj voi determina si parintele dar si filstrul, pentru ca filtru se afla in corespondenta cu tag-ul pe care s-a transmis imaginea. In continuare voi astepta primirea inaltimii blocului si a blocului propriu-zis. Voi face o impartire a liniilor primite la numarul de copii a fiecarul proces si voi trimite mai departe, latimea, noua inaltime si noual bloc. Secventa aceasta se repeta pana cand informatia ajunge la un nod de tip frunza. In continuare astept primirea blocului procesat de la fiecare copil. Dupa primirea blocului de la fiecare copil, pe baza tuturor blocurilor, construiesc unul pe care sa il transmit mai departe catre parinte. La finalul procesarii voi primi de la fiecare copil un numar corespunzator numarului de elemente ale vectorului de statistica si vectorul de statistica propriu-zis. Voi construi un singur vector la care voi adauga si valoarile pentru procesul curent si il voi transmite mai departe la procesele parinte.
	Pentru fiecare proces frunza, primesc latimea blocului ce urmeaza a fi procesat. Din acest prim mesaj determin parintele si filtrul ce sa vrea a fi procesat. Primesc mai apoi inaltimea si blocul propriu-zis. Aplic filtrul corespunzator canalului pe care s-au primit mesajele si transmit mai departe catre parinte blocul procesat. La finalul procesarii tuturor imaginilor, voi transmite mai departe un vector un mesaj pe canalul pentru mesaje de final, mesaj ce are valoare 2, adica in continuare voi transmite un vector de doua elemente. Acest voctor de statistica va contine id-ul procelui si cate linii a procesat.
	
	Mentionez ca atat pe statia locala cat si pe fep tema functioneaza conform cerintei. Am testat pe fep iar pentru cele 42 de imagini de procesat, pe ambele topologii, tema a functionat perfect. Va multumesc pentru intelegere si pentru timpul acordat!
