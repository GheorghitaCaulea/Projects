STUDENT: CAULEA Gheorghita
GRUPA: 	 324CB

PROBLEMA 1
	
	In inceputul implementarii am creat o clasa 'Interval' care sa ma ajute sa memorez obiecte de acest tip. Clasa contine doua atribute reprezentand capatul unui interval. Citesc din fisier punctele si intervalele si le adaug intr-o lista. Sortez lista de intervale dupa capatul din stanga. Aleg doua variabile cu care voi itera peste lista de intervale si lista de puncte. Cat timp nu am ajuns la finalul listei de puncte, caut primul interval in care se situeaza punctul si apoi intervalul cu cel mai mare capat dreapta in care se situeaza punctul. Dupa ce am iterat peste toate intervalele in care se afla punctul si am gasit intervalul cu capat dreapta maxim, iterez peste toate punctele care se incadreaza in acest interval. Cand un punct nu se va mai afla in interval voi incrementa contorul final de intervale si voi relua algoritmul.
	COMPLEXITATE: O(N + M) unde N este numarul de puncte si M este numarul de intervale.

PROBLEMA 2

	In inceputul implementarii am divizat problema in trei subprobleme corespunzatoare delor trei cazuri(doua siruri, trei siruri si respectiv patru siruri). 
	
	Pentru cazul cu doua siruri:
		Am creat o matrice bidimensionala(de memoizare) cu dimensiunile celor doua siruri plus unu. In acesta matrice pe pozitia [n][m](unde n reprezinta numarul de caractere al primului sir si m reprezinta numarul de caractere ala celui de-al doilea sir) am pus 'true' daca lungimea sirului rezultat este egala cu suma lungimilor celor doua siruri, in caz contrar m-am oprit. In continuare am parcurs matricea descrescator pe linii si descrescator pe coloane. Completarea matricicii presupune o recurenta de forma:
	a[i][j] = (a[i + 1][j] && s1[i] == rez[i + j]) || (a[i][j + 1] && s2[j] == rez[i + j]) reprezentand ca a[i][j] va fi 'true' daca a[i + 1][j] a fost 'true' si caracterul de pe pozitia 'i' al primului sir este identic cu caracterul de pe pozitia 'i + j' al sirului rezultat SAU daca a[i][j + 1] a fost 'true' si caracterul de pe pozia 'j' al celui de-al doilea sir este identic cu caracterul de pe pozitia 'i + j' al sirului rezultat. Problema recurentei este atunci cand (i + 1) > n sau (j + 1) > m si aceste cazuri le-am tratat separat.
	Rezultatul final se va afla pe pozitia a[0][0] si se va identifica cu posibilitatea sau imposibiliatatea construirii sirului final prin intrepatrunderea celor doua siruri.
	In acest caz COMPLEXITATEA metodei este: O(n * m) un n si m sunt cele de mai sus.

	Pentru cazul cu trei siruri:
		Similar cu cazul anterior, am creat o matrice cu trei dimensiuni(de memoizare) cu dimensiunile celor trei siruri plus unu. In acesta matrice pe pozitia [n][m][o](unde n reprezinta numarul de caractere al primului sir, m reprezinta numarul de caractere al celui de-al doilea sir si o reprezinta numarul de caractere al celui de-al treilea sir) am pus 'true' daca lungimea sirului rezultat este egala cu suma lungimilor celor trei siruri, in caz contrar m-am oprit. In continuare am parcurs matricea dupa logica de la cazul cu doua siruri. Completarea matricii a presupus de aceasta data o recurenta de forma: 
	a[i][j][k] = (a[i + 1][j][k] && s1[i] == rez[i + j + k]) || (a[i][j + 1][k] && s2[j] == rez[i + j + k]) || (a[i][j][k + 1] && s3[k] == rez[i + j + k]) unde a[i][j][k] va fi 'true' daca a[i + 1][j][k] a fost 'true' si caracterul de pe pozitia 'i' al primului sir este identic cu caracterul de pe pozitia 'i + j + k' al sirului rezultat SAU daca a[i][j + 1][k] a fost 'true' si caracterul de pe pozia 'j' al celui de-al doilea sir este identic cu caracterul de pe pozitia 'i + j + k' al sirului rezultat SAU daca a[i][j][k + 1] a fost 'true' si caracterul de pe pozia 'k' al celui de-al treilea sir este identic cu caracterul de pe pozitia 'i + j + k' al sirului rezultat. Problema recurentei este atunci cand (i + 1) > n sau (j + 1) > m sau (k + 1) > o si aceste cazuri le-am tratat separat.
    Rezultatul final se va afla pe pozitia a[0][0][0] si se va identifica cu posibilitatea sau imposibiliatatea construirii sirului final prin intrepatrunderea celor trei siruri.
	In acest caz COMPLEXITATEA metodei este: O(n * m * o) un n, m si o sunt cele de mai sus.

    Pentru cazul cu patru siruri:
		Similar cu cazul anterior, am creat o matrice cu patru dimensiuni(de memoizare) cu dimensiunile celor patru siruri plus unu. In acesta matrice pe pozitia [n][m][o][p](unde n reprezinta numarul de caractere al primului sir, m reprezinta numarul de caractere al celui de-al doilea sir, o reprezinta numarul de caractere al celui de-al treilea sir si p reprezinta numarul de caractere al celui de-al patrulea sir) am pus 'true' daca lungimea sirului rezultat este egala cu suma lungimilor celor patru siruri, in caz contrar m-am oprit. In continuare am parcurs matricea dupa logica de la cazul cu trei siruri. Completarea matricii a presupus de aceasta data o recurenta de forma: 
	a[i][j][k][h] = (a[i + 1][j][k][h] && s1[i] == rez[i + j + k + h]) || (a[i][j + 1][k][h] && s2[j] == rez[i + j + k + h]) 
                    || (a[i][j][k + 1][h] && s3[k] == rez[i + j + k + h]) || (a[i][j][k][h + 1] && s4[h] == rez[i + j + k + h]) unde a[i][j][k][h] va fi 'true' daca a[i + 1][j][k][h] a fost 'true' si caracterul de pe pozitia 'i' al primului sir este identic cu caracterul de pe pozitia 'i + j + k + h' al sirului rezultat SAU daca a[i][j + 1][k][h] a fost 'true' si caracterul de pe pozia 'j' al celui de-al doilea sir este identic cu caracterul de pe pozitia 'i + j + k + h' al sirului rezultat SAU daca a[i][j][k + 1][h] a fost 'true' si caracterul de pe pozia 'k' al celui de-al treilea sir este identic cu caracterul de pe pozitia 'i + j + k + h' al sirului rezultat SAU daca a[i][j][k][h + 1] a fost 'true' si caracterul de pe pozia 'h' al celui de-al patrulea sir este identic cu caracterul de pe pozitia 'i + j + k + h' al sirului rezultat. Problema recurentei este atunci cand (i + 1) > n sau (j + 1) > m, (k + 1) > o sau (h + 1) > psi aceste cazuri le-am tratat separat.
    Rezultatul final se va afla pe pozitia a[0][0][0][0] si se va identifica cu posibilitatea sau imposibiliatatea construirii sirului final prin intrepatrunderea celor trei siruri.
	In acest caz COMPLEXITATEA metodei este: O(n * m * o * p) un n, m, o si p sunt cele de mai sus.

PROBLEMA 3
    
    Rezolvarea acestei probleme a presupus parcurgerea vectorului de stropitori si verificarea implicita a asezarii fiecarei stropitori. Prima si ultima stropitoare au fost tratate separat. Restul stropitorilor au fost tratate dupa cum urmeaza: daca stropitoarea anterioara a fost fixata la stanga sau blocata, voi verifica daca pozitia stropitorii curente minus puterea ei va fi mai mare strict decat pozitia stropitorii anterioare. In caz pozitiv voi fixa stropitoarea curenta la stanga si voi incrementa contorul. Altfel, daca stropitoarea anterioara a fost fixata la dreapta si pozitia stropitorii curente minus puterea ei este mai mare strict decat pozitia stropitorii anterioare plus puterea ei, voi fixa stropitoare curenta la stanga si voi incrementa contorul. Altfel, daca nu pot fixa stropitoarea curenta la stanga voi verifica daca pozitia stropitorii curente plus puterea ei este mai mica decat pozitia stropitorii care urmeaza, in caz pozitiv fixandu-o la dreapta si incrementand contorul. Altfel, voi bloca stropitoarea curenta.
    COMPLEXITATE: O(n), unde n este numarul de stropitori.
    
