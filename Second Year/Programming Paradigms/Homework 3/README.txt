Student: CAULEA Gheorghita
Grupa:   324CB


	Am inceput implementarea temei pornind de la predicatele 'parse_char', 'parse_alpha', 'parse_int', 'star', 'plus', 'parse_var', 'parse_val', 'parse_tok' si 'parse_mult_expr', implementate la CURS. Am implementat predicatul 'parse_tok' care recunoaste si parseaza o variabila sau o valoare indiferent de numarul de caractere pe care acestea le poate avea. Am implementat predicatul 'parse_add_expr' care parseaza o expresie de tip adunare sau scadere, ambele avand aceiasi prioritate. Pentru adunare am parsat orice expresie pe care o intalneam pana la operatorul '+', inclusiv expresii de tip inmultire si mai apoi operatorul si restul expresiei. In cazul scaderii, la intalnirea operatorului '-' foloseam scoaterea lui '-' ca factor fortat si schimbarea toturor semnelor de dupa, folosindu-ma de variabila 'S' care imi spunea daca pana la acel moment am intalnit sau nu operatorul '-' si astfel stiind sa tratez fiecare caz. Logica implementarii era sa parsez toate expresiile de tip inmultire intalnite pana la operatorul '+' sau '-' si apoi dupa caz restul expresiei. Am implementat predicatul 'parse_smaller_expr' care parseaza o expresie de tip 'mai mic'. Logica implemetarii era sa parsez toate expresiile de tip adunare intalnite pana la operatorul '<', mai apoi operatorul si restul expresiei. Am implementat predicatul 'parse_equal_expr' care parseaza o expresie de tip 'egal'. Logica implementarii era sa parsez toate expresiile de tip 'mai mic' intalnite pana la momentul intalnirii operatorului '==', mai apoi operatorul si restul expresiei. Am implementat predicatul 'parse_expr' care apeleaza 'parse_equal_expr' si care va parsa toate expresiile posibile conform gramaticii. Am implementat predicatul 'get_expr' care extrage din lista de tokens toate elemetele unei posibile expresii pana la intalnirea unui ';'. Am implementat predicatul 'get_expr_if' care extrage din lista de tokens toate elementele unui posibile expresii pana la intalnirea unei ')'. Am implemetat predicatul 'get_prog' care obtine din lista de tokens toate elementele unui program, pana la intalnirea unei '}' care inchide programul. Pentru a sti care '}' inchide programul respectiv am folosit un contor pe care il initializam cu '0' si la fiecare intalnirea de '{' il incrementam si invers la intalnirea unei '}', astfel stiam ca '}' care inchide programul e cea intalnita cand variabila ce tine contorul este '0'. Am implementat predicatul 'parse_return' care parseaza un program de tip 'return'. Am implementat predicatul 'parse_assert' care parseaza un program de tip 'assert'. Am implemetat predicatul 'parse_assign_for' care parseaza un program de tip 'assign' care se afla intr-un program de tip 'for' si care e diferit de predicatul 'parse_assign' prin faptul ca cel din 'for' verifica situatia ca ultimul element sa fie de tip ')' in timp ce la celalalt predicat, ultimul element trebuie sa fie de tip ';'. Am implemetat predicatul 'parse_for' care parseaza un program de tip 'for'. Am implementat predicatul 'parse_if' care parseaza un program de tip 'if' si predicatul 'parse_semcol' care parseaza un program de tip ';'. Predicatul 'parse_prog' este implementat pentru a putea parsa orice tip de program iar predicatul 'parse_all_prog' parseaza o lista de programe. 
	
	In continuare variabilele folosite in implementarea predicatelor sunt urmatoarele si au urmatoarea insemnatate:
	R - reprezinta rezultatul evaluarii unuei expresii/program, daca este cazul
	E - reprezinta eroarea intoarsa in urma evaluarii unei expresii/program(0 - fara eroare, 1 - lipsa ruturn, 2 - assert nereusit, 3 - variabila neinitializata)
	D - reprezinta dictionarul(lista de liste in care retin perechi (variabila, valoare))
	S - o variabila ce anunta intalnirea unui 'return' (0 - nu s-a gasit 'return', 1 - altfel) 
	Am implementat predicatul 'search' care cauta intr-un dictionar, valoarea unei variabile. In cazul in care nu s-a gasit se intoarce eroare '3'(variabila neinitializata). Am implementat predicatul 'eval_expr' care evalueaza 
	- o variabila sau o valoare
	- o expresie de tip inmultire
	- o expresie de tip adunare
	- o expresie de tip scadere
	- o expresie de tip mai mic
	- o expresie de tip egal
In fiecare caz se evalueaza pe rand elementele constituiente ale expresiei si mai apoi se intoarce un rezultat sau o eroare, dupa caz.
	Am implementat predicatul 'eval_prog' care evalueaza:
	- un program de tip 'assign'. Se evalueaza expresia programului si daca evaluarea expresiei nu intoarce eroare se adauga in dictionar noua pereche. In caz contrar se intoarce eroare.
	- un program de tip 'assert'. Se evalueaza expresia programului si daca evaluarea expresiei nu intoarce eroare se intoarce un rezultat(0 - assert nereusit, 1 - assert reusit). In caz contrar se intoarce eroare de tip '2'.
	- un program de tip 'return'. Se evalueaza expresia programului si in cazul in care aceasta evaluare nu produce eroare se intoarce un rezultat si se initializeaza variabila ce anunta intalnirea unui return(S = 1). In caz contrar se intoarce o eroare.
	- un program de tip 'if'. Se evalueaza expresia si in cazul in caru nu esueaza sa evalueaza lista de programe conforme cu ramura pe care se merge. In caz contrar se intoarce eroarea.
	- un program de tip 'for'. Se evalueaza primul program de tip 'assign' si 'expresia' si in cazul in care nicio evaluare din aceste doua nu intoarce o eroare se evalueaza lista de programe corespunzatoare. Se va evalua in continuare acelasi program 'for' cu modificarea ca primul 'assign' se inlocuieste cu cel de-al doilea. Evaluarea inceteaza cand evaluarea expresiei nu produce rezultatul dorit sau se intoarce o eroare.
	- un program de tip 'semcol'.
	Am implementat predicatul 'eval_list_prog' care evalueaza pe rand fiecare program dintr-o lista de programe. Evaluarea listei se termina cand se ajunge la sfarsitul acesteia sau in momentul in care unul de programe are eroare sau contine 'return'.
	Predicatul 'parseInputAux' apeleaza predicatul 'parse_all_prog' si predicatul 'eval_list_prog' si intoarce rezultatul corespunzator.  